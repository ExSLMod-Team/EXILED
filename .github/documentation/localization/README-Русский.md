<h1 align="center">EXILED - EXtended In-runtime Library for External Development</h1>
<div align="center">

[<img src="https://img.shields.io/github/actions/workflow/status/ExMod-Team/EXILED/main.yml?style=for-the-badge&logo=githubactions&label=build" alt="CI"/>](https://github.com/ExMod-Team/EXILED/actions/workflows/main.yml/badge.svg?branch=master)
<a href="https://github.com/ExMod-Team/EXILED/releases"><img src="https://img.shields.io/github/v/release/ExMod-Team/EXILED?display_name=tag&style=for-the-badge&logo=gitbook&label=Release" alt="GitHub Releases"></a>
<img src="https://img.shields.io/github/downloads/ExMod-Team/EXILED/total?style=for-the-badge&logo=github" alt="Downloads">
![Github Commits](https://img.shields.io/github/commit-activity/w/ExMod-Team/EXILED/apis-rework?style=for-the-badge&logo=git)
<a href="https://discord.gg/PyUkWTg">
<img src="https://img.shields.io/discord/656673194693885975?style=for-the-badge&logo=discord" alt="Chat on Discord">
</a>

</div>
EXILED - высокоуровневый фреймворк для серверов SCP: Secret Laboratory. Он предлагает систему событий, которую разработчики могут использовать для различных манипуляций, изменения кода игры или реализации собственных функций. Все события EXILED сделаны с помощью Harmony, что исключает необходимость прямого редактирования серверных сборок. Это обеспечивает два важных преимущества:

- Во-первых, весь код фреймворка может быть свободно опубликован и распространен, что позволяет разработчикам лучше понять, *как* он работает, а также предложить свои предложения по дополнению или изменению его функций.
- Во-вторых, поскольку весь код, связанный с фреймворком, выполняется вне сборки сервера, такие вещи, как небольшие обновления игры, будут иметь незначительное влияние на фреймворк, если вообще будут иметь. Это делает его наиболее совместимым с будущими обновлениями игры, а также облегчает обновление, когда это *нужно* сделать.

# Установка
Установка EXILED довольно проста. Он загружается через Plugin API Northwood. Именно поэтому в архиве ``Exiled.tar.gz``, доступном в релизах, находятся две папки: ``SCP Secret Laboratory`` и ``EXILED``. Просто переместите их в указанные ниже пути и всё готово!

Если вы выберете установку через установщик, он автоматически выполнит все необходимые шаги.

# Windows
### Автоматическая установка ([подробнее](../../../EXILED/Exiled.Installer/README.md))
**Примечание**: Убедитесь, что вы используете учётную запись, с которой запускается сервер, или обладаете правами администратора.

- Скачайте **`Exiled.Installer-Win.exe` [отсюда](https://github.com/ExMod-Team/EXILED/releases)** (нажмите на Assets -> выберите Installer).
- Поместите его в папку вашего сервера (если вы еще не скачали выделенный сервер)
- Дважды щелкните **`Exiled.Installer.exe`** или **[скачайте этот .bat](https://www.dropbox.com/scl/fi/7yh0r3q0vdn6ic4rhuu3l/install-prerelease.bat?rlkey=99fwjbwy1xg61qgtak0qzb9rd&st=8xs4xks8&dl=1)** и поместите его в папку сервера для установки последней предварительной версии.
- Чтобы установить и получить плагины, ознакомьтесь с разделом [Установка плагинов](#установка-плагинов-windows) ниже.
  **Примечание:** Если вы устанавливаете EXILED на удаленный сервер, убедитесь, что вы запустили .exe от имени того же пользователя, который запускает ваши серверы SCP:SL (или пользователя с правами администратора).

### Установка вручную
- Скачайте **`Exiled.tar.gz` [отсюда](https://github.com/ExMod-Team/EXILED/releases)**.
- Распакуйте его содержимое с помощью [7Zip](https://www.7-zip.org/) или [WinRar](https://www.win-rar.com/download.html).
- Переместите папку **`EXILED`** в **`%appdata%`** *Примечание: Эта папка должна находиться в ``C:\Users\%UserName%\AppData\Roaming``, и ***НЕ*** ``C:\Users\%UserName%\AppData\Roaming\SCP Secret Laboratory``, и **ЭТО ДОЛЖНО** быть в (. ...)\AppData\Roaming, а не (...)\AppData\!*.
- Переместите **``SCP Secret Laboratory``** в **`%appdata%`**.
  - Windows 10 & 11:
    Введите `%appdata%` в Cortana, строку поиска или адресную строку проводника Windows.
  - Другие версии Windows:
    Нажмите Win + R и введите `%appdata%`.

### Установка плагинов Windows
На этом установка EXILED завершена, и он будет активен при следующем запуске сервера. Обратите внимание, что EXILED сам по себе почти ничего не делает, поэтому обязательно посмотрите плагины на **[нашем Discord сервере](https://discord.gg/PyUkWTg)**.
- Чтобы установить плагин, просто:
  - Скачайте плагин с [*их* страницы релизов](https://i.imgur.com/u34wgPD.jpg) (**он ДОЛЖЕН быть `.dll`!**)
  - Переместите его в: ``C:\Users\%UserName%\AppData\Roaming\EXILED\Plugins`` (переместите его сюда, нажав Win + R, а затем написав `%appdata%`)

# Linux
### Автоматическая установка ([подробнее](../../../EXILED/Exiled.Installer/README.md))

**Примечание:** Если вы устанавливаете EXILED на удаленный сервер, убедитесь, что вы запускаете программу установки от имени того же пользователя, который запускает ваши серверы SCP:SL (или root).

- Скачайте **`Exiled.Installer-Linux` [отсюда](https://github.com/ExMod-Team/EXILED/releases)** (нажмите на Assets -> нажмите на Installer).
- Установите его, набрав **`./Exiled.Installer-Linux --path /путь/к/серверу`** или переместив его в папку сервера напрямую, перейдите в нее с помощью терминала (`cd`) и наберите: **`./Exiled.Installer-Linux`**.
- Если вам нужна последняя предварительная версия, просто добавьте **`--pre-releases`**. Пример: **`./Exiled.Installer-Linux /home/scp/server --pre-releases`**.
- Другой пример, если вы поместили `Exiled.Installer-Linux` в папку вашего сервера: **`/home/scp/server/Exiled.Installer-Linux --pre-releases`**
- Чтобы установить и получить плагины, ознакомьтесь с разделом [Установка плагинов](#установка-плагинов-linux) ниже.

### Установка вручную
- **Убедитесь**, что вы вошли в систему под пользователем, который запускает SCP-серверы.
- Скачайте **`Exiled.tar.gz` [отсюда](https://github.com/ExMod-Team/EXILED/releases)** (SSH: щелкните правой кнопкой мыши и получите ссылку `Exiled.tar.gz`, затем введите: **`wget (link_to_download)`**)
- Чтобы извлечь его в текущую папку, введите **``tar -xzvf EXILED.tar.gz``**.
- Переместите **`SCP Secret Laboratory`** папку в **``~/.config``**. *Примечание: Эта папка должна находиться в ``~/.config``, а ***НЕ В*** ``~/.config/SCP Secret Laboratory``* (SSH: **`mv SCP Secret Laboratory ~/.config/`**)
- Переместите папку **`EXILED`** в **``~/.config``**. *Примечание: Эта папка должна находиться в ``~/.config``, и ***НЕ В*** ``~/.config/SCP Secret Laboratory``* (SSH: **`mv EXILED ~/.config/`**)

### Установка плагинов Linux
На этом установка EXILED завершена, и он будет активен при следующем запуске сервера. Обратите внимание, что EXILED сам по себе почти ничего не делает, поэтому обязательно посмотрите плагины на **[нашем Discord сервере](https://discord.gg/PyUkWTg)**.
- Чтобы установить плагин, просто:
  - Скачайте плагин с [*их* страницы релизов](https://i.imgur.com/u34wgPD.jpg) (**он ДОЛЖЕН быть `.dll`!**)
  - Переместите его в: ``~/.config/EXILED/Plugins`` (если вы используете SSH как root, то ищите нужный `.config`, который будет находиться в `/home/(SCP Server User)``)

# Конфигурация
EXILED сам по себе предлагает некоторые опции конфигурации.
Все они автоматически генерируются при запуске сервера и находятся в файле ``~/.config/EXILED/Configs/(ПортСервера)-config.yml`` (``%AppData%\EXILED\Configs\(ПортСервера)-config.yml`` на Windows).

Конфигурации плагинов ***НЕ*** будут находиться в файле ``config_gameplay.txt``, вместо этого они устанавливаются в файле ``~/.config/EXILED/Configs/(ПортСервера)-config.yml`` (``%AppData%\EXILED\(ПортСервера)-config.yml`` на Windows).
Однако некоторые плагины могут получать свои настройки конфигурации из других мест самостоятельно, это просто место по умолчанию для них в EXILED'е, поэтому при возникновении проблем обратитесь к отдельному плагину.

# Для разработчиков

Если вы хотите создать плагин для EXILED, сделать это довольно просто. Если вы хотите получить более подробное руководство, посетите нашу страницу [Начало работы](../GettingStarted.md).

Более полные и активно обновляемые руководства вы найдете на [сайте EXILED](https://exmod-team.github.io/EXILED/).

Основные правила для разработчиков:

- Ваш плагин должен содержать класс, наследуемый от ``Exiled.API.Features.Plugin<>``. Иначе EXILED не загрузит его при запуске сервера.
- Когда плагин загружен, код в методе ``OnEnabled()`` вышеупомянутого класса срабатывает немедленно, он не ждет загрузки других плагинов. Он не ждет завершения процесса запуска сервера. ***Он не ждет ничего.*** При настройке метода ``OnEnabled()`` убедитесь, что вы не обращаетесь к объектам, которые еще не инициализированы сервером, таким как ``ServerConsole.Port`` или ``PlayerManager.localPlayer``.
- Если вам нужно получить доступ к элементам, которые не инициализированы до загрузки плагина, рекомендуется просто дождаться события ``WaitingForPlayers``. Если по какой-либо причине вам нужно сделать это раньше, оберните код в цикл ``while(!x)``, который проверяет, что переменная/объект, который вам нужен, больше не является ``null``, прежде чем продолжить.
- EXILED поддерживает динамическую перезагрузку сборок плагинов во время выполнения, что позволяет обновлять плагин без перезапуска сервера, однако для поддержки этой функции плагин должен быть корректно настроен. Обратитесь к разделу ``Динамические обновления`` для получения дополнительной информации и рекомендаций.
- В EXILED ***НЕТ*** событий OnUpdate, OnFixedUpdate или OnLateUpdate. Если вам по какой-либо причине нужно запускать код так часто, вы можете использовать MEC-корутину, которая ждет один кадр, 0.01f, или использовать временной слой, например Timing.FixedUpdate.

### MEC Coroutines
Если вы не знакомы с MEC, это будет очень краткий и простой учебник, который поможет вам начать работу.
MEC Coroutines - это методы с таймером, которые поддерживают периоды ожидания перед продолжением выполнения, не прерывая основной поток игры.
Они безопасны для использования с Unity, в отличие от традиционных потоков. ***НЕ пытайтесь создавать новые потоки для взаимодействия с Unity, они приведут к крашу сервера.***

Чтобы использовать MEC, добавьте ссылку на ``Assembly-CSharp-firstpass.dll`` из файлов сервера и напишите ``using MEC;``.
Пример вызова простой корутины, которая повторяет себя с задержкой между каждым циклом:
```cs
using MEC;
using Exiled.API.Features;

public void SomeMethod()
{
    Timing.RunCoroutine(MyCoroutine());
}

public IEnumerator<float> MyCoroutine()
{
    for (;;) // Бесконечно повторять следующие действия
    {
        Log.Info("Эй, Я бесконечный цикл!"); // Вызов Log.Info для печати строки в журналы игровой консоли/сервера.
        yield return Timing.WaitForSeconds(5f); // Говорит coroutine подождать 5 секунд перед продолжением, поскольку это происходит в конце цикла, это эффективно останавливает цикл от повторения на 5 секунд.
    }
}
```

***Настоятельно*** рекомендуется погуглить или спросить в Discord, если вы не знакомы с MEC и хотите узнать больше, получить совет или нуждаетесь в помощи. На вопросы, независимо от того, насколько они "глупые", всегда будут даны максимально полезные и понятные ответы, чтобы разработчики плагинов могли преуспеть. Лучший код лучше для всех.

### Динамические обновления
EXILED как фреймворк поддерживает динамическую перезагрузку сборок плагинов, не требуя перезагрузки сервера.
Например, если вы запускаете сервер с единственным плагином `Exiled.Events` и хотите добавить новый, вам не нужно перезагружать сервер для выполнения этой задачи. Вы можете просто использовать команду `reload plugins` в RemoteAdmin или в консоли сервера для перезагрузки всех плагинов EXILED, и загрузки новых, которые не были загружены ранее.

Это также позволяет *обновлять* плагины без полной перезагрузки сервера. Однако чтобы это было сделано должным образом, разработчик плагина должен следовать нескольким рекомендациям:

***Для хостеров***
- Если вы обновляете плагин, убедитесь, что имя его сборки не совпадает с именем текущей установленной версии (если таковая имеется). Чтобы это сработало, плагин должен быть создан разработчиком с учетом динамических обновлений, простое переименование файла не поможет.
- Если плагин поддерживает динамические обновления, то перед перезагрузкой EXILED убедитесь, что когда вы помещали новую версию плагина в папку "Plugins", вы также удалили старую версию из папки. Несоблюдение этого требования приведет ко многим и многим плохим вещам.
- Ответственность за любые проблемы, возникающие при динамическом обновлении плагина, лежит исключительно на вас и разработчике данного плагина. Хотя EXILED полностью поддерживает и поощряет динамическое обновление, единственная возможность, что оно может не сработать или пойти не так, это если хост сервера или разработчик плагина сделали что-то не так. Прежде чем сообщать разработчикам EXILED об ошибке, связанной с динамическим обновлением, трижды проверьте, что все было сделано правильно обеими сторонами.

***Для разработчиков***

- Плагины, которые хотят поддерживать динамическое обновление, должны отписываться от всех событий к которым они подключены, когда они отключены или перезагружены.
- Плагины, имеющие собственные патчи Harmony, должны использовать какую-либо изменяемую переменную в имени экземпляра Harmony, и вызывать ``UnPatchAll()`` для своего экземпляра, когда плагин отключен или перезагружен.
- Любые корутины, запущенные плагином в ``OnEnabled()``, также должны быть завершены при отключении или перезагрузке плагина.

Все это можно сделать в методах ``OnReloaded()`` или ``OnDisabled()`` в классе плагина. Когда EXILED перезагружает плагины, он вызывает ``OnDisabled()``, затем ``OnReloaded()``, затем загружает новые сборки, а затем выполняет ``OnEnabled()``.

Обратите внимание, что загружаются именно *новые* сборки. Если вы замените сборку другой сборкой с таким же именем, она ***НЕ*** будет обновлена. Это связано с GAC (Global Assembly Cache), если вы попытаетесь "загрузить" сборку, которая уже находится в кэше, то вместо нее всегда будет использоваться кэшированная сборка.
По этой причине, если ваш плагин будет поддерживать динамические обновления, вы должны собирать каждую версию с другим именем сборки в опциях сборки (переименование файла не работает). Также, поскольку старая сборка не "уничтожается", то вы не сможете отписаться, распатчить ваш экземпляр, остановить корутины и т.д., этот код будет продолжать выполняться, как и код новой версии.
Это очень плохо.

Таким образом, плагины, поддерживающие динамические обновления, ***ОБЯЗАНЫ*** следовать этим рекомендациям, иначе они будут удалены с сервера Discord из-за потенциального риска для владельцев сервера.

Но не каждый плагин должен поддерживать динамические обновления. Если вы не собираетесь поддерживать динамические обновления, это совершенно нормально, просто не меняйте имя сборки плагина при создании новой версии. В этом случае не нужно беспокоиться о других аспектах. Убедитесь, что владельцы серверов знают, что для обновления плагина потребуется полная перезагрузка серверов.

Перевод сделал Ficus-x при помощи IRacle и Remuchi.
